<week>
<programming-general>
	<thoughts>	
    TDD를 사용하는 나의 멘탈 모델.
    TDD는, 기존에 내가 하던 Top-Down 프로그래밍을 정당화하는 방법론이자 워크 플로우이다.
    원래 탑-다운 어프로치는 쉽지 않다. 프로그램의 로우 레벨 컴포넌트, 즉 클래스나 함수, 메서드의
    역할과 적절한 구현 방법을 익히고 있지 않으면, 막상 탑-다운 어프로치로 프로그램을 작성하려고 해도
    잘 되지 않는다. 잘 되지 않는다는 것은, 의식적으로 편하지 않기 때문에, 프로그래밍에 임할 때 손이 쉽게 나가지 않는다.
    또 다른 문제는, LLM을 사용할 때의 생성되는 코드는, 인터페이스와 구현을 동시에 가지고 있기 때문에, 
    프로그래머가 인터페이스 설계부터 시작하는 워크플로우를 방해한다.
    코드는 근본적으로 인터페이스보다 구현쪽의 코드가 방대하기 때문에, LLM의 결과물처럼 이미 구현 코드가 완성되어있는
    코드베이스의 경우, 코드를 이해하는데 시간이 많이 걸리고, 좋은 인터페이스로 분리하는 수고가 많이 든다.

    반면, Bottom-Up 어프로치는 더욱 어렵다. 탑-다운 어프로치보다 어떤 인터페이스가 필요될지 더욱 정확히 
    예측해야하며, 따라서 불필요한 코드를 생산할 가능성이 높고 이는 생산성에 악영향을 미친다.

    TDD는, 이처럼 그 명성에 더해서, 최신 소프트웨어 생산 트렌드에도 강한 내성을 갖는 프로그래밍 워크플로우이며,
    동시에 코드베이스의 기능적 요구사항의 만족을 보장하는 방법론이다.

    무엇보다 매력적인 점은, 탑-다운 어프로치는 실제 결과물과는 별개로 코드를 작성하는 과정에서, 프로그래머의 사고의
    흐름을 코드로 전환하는 보다 자연스러운 방법이다. 프로그래머는 보통 "좋은 품질의 코드"를 생산하기를 원한다.
    좋은 품질의 코드는 무엇보다 좋은 인터페이스를 갖는 것이다. 자신이 얻고싶은 적절하게 추상화된 인터페이스를 갖는 코드를 구현하는 
    흐름이 바로 탑-다운 어프로치가 되는 것이다. 반면 바텀-업 어프로치는 그 사고와는 반대의 순서로 구현하기 때문에
    생산성의 저하가 있을 수 있다.

    TDD는 이런 맥락에 따라, 동작하는 코드를 보장하면서도, 프로그래머가 만들고자하는 것(이상적인 인터페이스를 구현하고자하는 사고의 흐름)을 자유롭게 실천하도록 유도한다. 말하자면 프로그램의 정확성, 정합성 등을 보장하는 "가이드라인", "가드레일"을 제공하는 것 안에서, 프로그래머가 원하는 형태와 흐름의 코드를 마음껏 작성하게 도와준다.
	</thoughts>
</programming-general>

<music>
	<new>
	</new>
</music>

<video>
</video>

<personal-development>
</personal-development>

<team-development>
  topster_image_rendering_app의 테스트 시나리오 1을 위한 실패하는 테스트 작성.
</team-development>

<language-learning>
</language-learning>

<life>
  일본 주거지역 조사하기. 키치죠지, 세이세키-사쿠라가오카, 덴엔초우 등 새롭게 알게된 추천 주거지를 알게됨.
  새로 살 캐리어, 가방 탐색. 아메리칸 투어리스터가 싸긴하다.
  캐리어를 새로 제일 큰걸 사고, 백은 있는거 가져가자.
</life>
<reviews>
  <weekly>
  </weekly>
</reviews>
</week>
